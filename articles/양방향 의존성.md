# 양방향 의존성

로또 미션을 진행하던 중, 로또 번호를 가지는 Lotto 클래스와 당첨 번호와 보너스 번호를 함께 관리하는 WinLotto 클래스 간에 양방향 의존성이 발생한다는 리뷰를 받았다.

```kotlin
class Lotto(val numbers: Set<LottoNumber>) {
	fun determineRank(condition: Rank, winLotto: WinLotto): Boolean {
	}
}
```

```kotlin
class WinLotto(val winNumber: Lotto, val bonus: LottoNumber) {
}
```

WinLotto 클래스는 Lotto와 연관 관계를 맺고 있고, Lotto 클래스는 WinLotto클래스와 의존 관계를 맺고 있다. 서로 의존성을 가지고 있을 때, 양방향 의존성이 발생한다고 표현한다. 이는 어떤 문제를 가지고 있을까?

## 객체 관계 설계

객체지향에서 객체는 ‘상태’를 가지고 ‘행동’을 하는 주체이다. 각 객체는 본인만의 뚜렷한 역할을 가지고 있어야 한다. 외부에서는 ‘상태’에 대해 알 필요는 없고 ‘메시지’를 던져서 ‘행동’을 하라고 명령을 해야 하고 이로 인해 각 객체의 역할을 수행하도록 한다. 이때 메시지를 던지는 관계를 의존성이라고 하고, 이 의존성을 어떻게 관리하느냐에 따라 좋은 설계인지 나쁜 설계인지 나뉜다.

## 나쁜 의존성

![Untitled](articles/images/0/Untitled.png)

위 예시를 보면 Consumer는 Monitor를 참조하고, Monitor는 Stopper를 참조한는데, Stopper는 Consumer를 참조하고 있다. 이를 순환 의존성이 발생했다고 한다. 이 세 개의 객체는 각 객체에 변경점이 발생했을 때 모두 대응해 주어야 하며, 테스트를 할 때도 모두 빌드하고 통합되어야 하며, 메소드 순환 호출등이 발생할 수 있다.

이는 사실상 하나의 거대한 객체가 되었다고 보여진다.

## 해결 방법

위의 경우는 단순히 잘못된 설계로 determineRank 함수를 WinLotto 클래스로 옮기는 것으로 해결되었지만 좀 더 복잡한 경우는 어떻게 해결해야 할까?

### 중간 객체를 이용한 순환 끊기

- 의존성이 발생한 객체가 모두 의존하는 새로운 객체를 만들고, 의존성이 발생한 객체가 의존하는 모든 함수를 새로운 객체로 이동한다.
- 중간 객체를 이용해 의존성 역전을 이루어 내었다.

### 의존성 역전 원칙 (DIP : Dependency Inversion Principle)

- 상위 모듈은 하위 모듈에 의존해서는 안 되고 둘 다 추상화에 의존해야 한다.
- 추상화는 세부 사항에 의존해서는 안 되고 세부사항은 추상화에 의존해야 한다.

### 인터페이스와 그 구현으로 의존성 역전

- Stopper가 필요로 하는 메소드를 제공하는 인터페이스를 생성한다.
    - Producer와 Consumer에 참조하는 메소드에 대한 인터페이스 생성
    - Producer와 Consumer는 해당 인터페이스 상속
- 이로 인해 의존성을 역전시키고 순환을 끊을 수 있다.